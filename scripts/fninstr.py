import sys
import yaml
import re
import cPickle as pickle
import argparse


"""
This script consumes the output of lavaFnTool.  That output is one
yaml file per file of source code.  The yaml file is a sequence of 
entries that are one of the following: 

Function          -- either a fn prototype or a fn definition
Call              -- call to a function 
Fn Ptr assignment -- a fn pointer assigned to something

Function and Call entries indicate fn name, args and their types,
ret value type. For function entries, we also know if if we have the 
function body, indicating it is a user-defined fn.  For call entries,
we also know the containing function as well as whether or not this
call is through a fn pointer.  We also know, for calls, if any of the
args are functions.

Function ptr assignment really just tells us which of the functions
are ever assigned to fn pointers.  


Here is an example function entry.

- fun:
   start: grep-pre.c:8301:1
   end: grep-pre.c:8341:1
   name: fgrep_to_grep_pattern
   hasbody: true
   fundecl:
      extern: False
      ret_type: void
      params:
         - param: char **
         - param: size_t *

Here is an example call entry (of that fn)

- call:
   start: kwsearch-pre.c:6175:15
   end: kwsearch-pre.c:6175:73
   fnptr: false
   name: fgrep_to_grep_pattern
   containing_function: Fexecute
   ret_type: void
   args:
      - arg:
         name: None
         type: char **
         info: None
      - arg:
         name: None
         type: size_t *
         info: None

Here is an example fnPtrAssign entry

- fnPtrAssign:
   start: kwset-pre.c:4575:3
   end: kwset-pre.c:4575:20
   name: acexec
   fundecl:
      extern: False
      ret_type: ptrdiff_t
      params:
         - param: kwset_t
         - param: const char *
         - param: ptrdiff_t
         - param: struct kwsmatch *
         - param: _Bool


Note that we have this information for *all* pre-processed source files 
in the project, i.e., for the whole program. This means we can hold 
in our head, all at once, this information for the entire program.
The job of fninstr.py is to use all that whole-program info to decide 
which code to instrument with bugs (or to modify in other ways such as 
diversify). Why is this powerful? Say that function merp is called in source 
file foo.c. If merp is not defined in foo.c then we can't tell if merp 
is a library function or not. So we can't know, by just looking at foo.c, 
whether or not we can mess with the arguments to merp (permute them, add new 
ones, etc). We have to have the output of lavaFnTool for another source file, 
say, bar.c, where merp is defined and has a body, to know that merp can be 
instrumented.  


Here's what we do with all those yaml files generated by lavaFnTool.

1. First analysis.

Determine complete set of named function in any source file.  
Also determined all fns passed as args.  
Three sources of information for this.

* Function definitions. We know it's a definition if it contains an implementation (body)
* Function declarations (prototype, with return type, and param types)
* Function calls.  No fn should be called unless we have a prototype for it?  If we are looking at preprocessed code.

2. Second analysis.

Determine which functions we will instrument. This is a little more
complicated than determining which are internal functions for which
we have bodies and which are not. When we say we will instrument a
function we mean both of the following.

  * Adding lava queries to body (that could later find DUAs or ATPs
    under taint analysis).
  * If we are using data flow, then it also means adding data_flow
    first arg to defn, prototype, and all calls

When do we instrument a function 'foo'?

  * Obviously, only if 'foo' has an implmentation (body) can it be
    a candidate to be instrumented in the first place.

  * Say a function 'foo' is a candidate for instrumentation. But
    'foo' is passed, as a paramenter, to another function, 'bar'.
    If 'bar' is not a candidate for instrumention then neither can
    'foo' be since calls to 'foo' from bar can't be instrumented.
    Note that resolving this sort of relation requires recursing.

  * If a function's body isnt instrumented then calls to that function
    cannot be instrumnted with data_flow arg.

  * Probably we can safely ignore 'extern' since it is often, oddly,
    applied to functions for which we observe a body.

3. Deal with instrumentable fns passed to uninstrumentable fns.

Make another pass to see if there are any fns passed as args to
other fns that are, themselves, not instrumentable.  Which means
they, too, cannot tolerate a change in prototypes (data_flow arg).

4. Deal with instrumentable fn called from within non-instrumentable fn

If fn1 is un-instrumentable, and if contains calls
to fn2, then fn2 also cannot be instrumented.

5. Final pass involves complicated analysis involving fn type equivalence
classes.  And it all seems to work but (on grep, at least) it didnt seem
ultimately to be required.  

"""

debug = True

# When IGNORE_FN_PTRS is set, we don't inject dataflow as an argument when a
# function pointer is called. This needs to match with the same variable
# in lavaTool/include/MatchFinder.h
# Note, no tests pass if this is true
# TODO: parameterize this
IGNORE_FN_PTRS = False


parser = argparse.ArgumentParser(description='Use output of LavaFnTool to figure out which parts of preproc code to instrument')

# TODO use vars.py to figure this out instead of arguments
parser.add_argument('-d', '--dataflow', action="store_true", default=False,
                    help="lava is using dataflow")
parser.add_argument('-i', '--input', action="store", default=None,
                    help="name of input yaml file from LavaFnTool")
parser.add_argument('-o', '--output', action="store", default=None,
                    help="name of output yaml file containing instrumentation decisions")

(args,rest) = parser.parse_known_args()

data_flow = args.dataflow


def parse_fundecl(fd):
    ret_type = fd['ret_type']
    params = fd['params']
    if 'extern' in fd:
        ext = fd['extern']
    else:
        ext = None
    return (ext, ret_type, params)


def check_start_end(x):
    start = x['start']
    end = x['end']
    f1 = start.split(":")[0]
    f2 = end.split(":")[0]
    assert (f1 == f2)
    return (f1, start, end, start==end)


class FunctionType:

    def __init__(self, yaml):
        if 'fun' in yaml:
            fd = yaml['fun']['fundecl']
            self.rt = fd['ret_type']
            if fd['params'] is None:
                self.pt = None
            else: 
                self.pt = []
                for p in fd['params']:
                    self.pt.append(p['param'])
        elif 'call' in yaml:
            c = yaml['call']
            self.rt = c['ret_type']
            self.pt = []
            if c['args'] is None:
                self.pt = None
            else:
                for a in c['args']:
                    self.pt.append(a['arg']['type'])
        else:
            print "Function type for non fun or call?"
            assert (1==0)

    def __str__(self):
        ss = self.rt + " (*)("
        if self.pt is None: 
            ss += ")"
        else :
            n = len(self.pt)
            i=1
            for p in self.pt:
                if i < n:
                    ss += p + ", "
                else:
                    ss += p + ")"
                i += 1
        return ss

    def __repr__(self):
        return self.__str__()

    def __eq__(self, other):
        if isinstance(other, FunctionType):
            return ((self.rt == other.rt) and (self.pt == other.pt))
        else:
            return False

    def __ne__(self, other):
        return (not self.__eq__(other))

    def __hash__(self):
        return hash(self.__str__())
        


class Function:

    def __init__(self, fun):
        (self.filename, self.start, self.end, see) = check_start_end(fun)
        self.name = fun['name']
        (self.extern, self.ret_type, self.params) = parse_fundecl(fun['fundecl'])
        self.hasbody = fun['hasbody']
        if self.hasbody:
            assert (not see)



class FnPtrAssign:

    def __init__(self, fpa):
        (self.filename, self.start, self.end, see) = check_start_end(fpa)
        (self.extern, self.ret_type, self.params) = parse_fundecl(fpa['fundecl'])
        # this is the value being assigned to the fn ptr, i.e. the RHS
        self.name = fpa['name']
        assert (not see)


class Call:

    def __init__(self, call):
        # this is the name of the fn called
        self.name = call['name']
        # and this is what fn the call is in
        self.containing_function = call['containing_function']
        (self.filename, self.start, self.end, see) = check_start_end(call)
        self.fnptr = call['fnptr']
        self.args = call['args']
        self.ret_tyep = call['ret_type']
        assert (not see)


fundefs = {}
funtypes = {} 
prots = {}
calls = {}
fpas = {}

def addtohl(h,k,v):
    if not (k in h):
        h[k] = []
    h[k].append(v)


def merge(v, vors):
    if v is None:
        assert (vors is None)
        return
    if vors is None:
        assert (v is None)
    return vors + v

if True:
    for filename in rest:
        print "FILE [%s] " % filename
        y = yaml.load(open(filename))
        for x in y:
    #        print x
            if 'fun' in x:
                fd = Function(x['fun'])
                if fd.start == fd.end:
                    continue
                if fd.hasbody:
                    addtohl(fundefs, fd.name, fd)
                else:
                    addtohl(prots, fd.name, fd)
                ft = FunctionType(x)
                fd.type = ft
                if not (ft in funtypes):
                    funtypes[ft] = set([])
                funtypes[ft].add(fd.name)
            elif 'call' in x:
                call = Call(x['call'])
                addtohl(calls, call.name, call)                
            elif 'fnPtrAssign' in x:
                fpa = FnPtrAssign(x['fnPtrAssign'])
                addtohl(fpas, fpa.name, fpa)

    f = open("getfns.pickle", "w")
    pickle.dump(fundefs, f)
    pickle.dump(prots, f)
    pickle.dump(calls, f)
    pickle.dump(fpas, f)
    f.close()
else:
    f = open("getfns.pickle", "r")
    fundefs = pickle.load(f)
    prots = pickle.load(f)
    calls = pickle.load(f)
    fpas = pickle.load(f)
    f.close()


# 1. Determine complete set of named function we have seen. 

all_fns = set()
fns_passed_as_args = {}
for name in prots.keys():
    all_fns.add(name)

print "%d fn names in prots" % (len(all_fns))
for name in fundefs.keys():
    all_fns.add(name)
print "%d fn names in prots+fundefs" % (len(all_fns))
for name in calls.keys():
    all_fns.add(name)
print "%d fn names in prots+fundefs+calls" % (len(all_fns))
for name in calls.keys():
    # examine args in each of the calls
    # to see if any are passing a function or fn pointer
    for call in calls[name]:
        if not (call.args is None):
            for item in call.args:
                arg = item['arg']
                if not arg: continue
                if arg['info'] == "function" and arg['name'] != "None":
                    all_fns.add(arg['name'])
                    addtohl(fns_passed_as_args, arg['name'], call.name)

print "%d fn names in prots+fundefs+calls+callargs" % (len(all_fns))


# returns True if fn with this name (fnname)
# is either assigned to a fn pointer or is passed as an arg 
def alias(fnname):
    if (name in fpas) or (name in fns_passed_as_args):
        return True
    else:
        return False

# returns True if fn with this name (fnname)
# DOES not have a body
def hasbody(fnname):
    if name in fundefs:
        hb = False
        for fd in fundefs[name]:
            if (fd.hasbody):
                return True
    return False

            
fn2funtype = {}

for ft in funtypes.keys():
    print "Function type: " + (str(ft))
    for name in funtypes[ft]:
        fn2funtype[name] = ft
        print "  " + name
        if alias(name):
            print "    alias"
        else:
            print "    no_alias"
        if hasbody(name):
            print "    body"
        else:
            print "    no_body"

            
# 2. Determine which functions we will instrument. 


instr_judgement = {}

# ok to instrument
OKI = 0
# don't instrument body
DIB = 1
# don't add data flow arg
DADFA = 2

for name in all_fns:
    if hasbody(name):
        instr_judgement[name] = OKI
        if debug:
            print  "Instr candidate %s has body" % name
    else:
        # we dont have body for this fn.  can't instrument at all
        instr_judgement[name] = DIB | DADFA
        if debug:
            print "Won't instrument %s at all since we don't have body" % name


def get_instr():
    instr = set()
    for name in instr_judgement.keys():
        if instr_judgement[name] == OKI:
            instr.add(name)
    return instr

instr = get_instr()
print "%d instrumnetable fns to start" % (len(instr))
print "----------------------------------------------------------------"


# 3. Deal with instrumentable fns passed to uninstrumentable fns.
#  
# NB: Must iterate to get everything

any_change = True
while any_change:
    n_rej = 0
    for name in instr:
        if name in fns_passed_as_args:
            disposition = OKI
            for called_fn in fns_passed_as_args[name]:
                if not (instr_judgement[called_fn] == OKI):
                    print "Won't instrument %s since it is passed to uninstrumentable fn %s" % (name, called_fn)
                    disposition |= DADFA
                    disposition |= DIB                    
                    n_rej += 1
                    break
            # fn is not ok to instrument
            if not (disposition is OKI):
                instr_judgement[name] = disposition
    print "%d functions rejected bc passed to uninstrumentable fns" % n_rej
    any_change = False
    if n_rej > 0: 
        any_change = True
    instr = get_instr()

print "%d instrumnetable fns after dealing with fns passed to uninstrumentable fns" % (len(instr))
print "----------------------------------------------------------------"


if IGNORE_FN_PTRS:
    for name in fpas:
        instr_judgement[name] |=  DADFA | DIB

# 4. Deal with instrumentable fn called from within non-instrumentable fn
#
# NB: Again, we must iterate.  If, in an iteration we decide something in non-instrumentable
# that can effect other fns called from within that fn.

any_change = True
while any_change:
    any_change = False
    n_rej = 0
    for called_fn_name in calls.keys():
        if (instr_judgement[called_fn_name] is OKI):
            # We 'think' we can instrument called_fn_name
            for call in calls[called_fn_name]:
                if (not (instr_judgement[call.containing_function] is OKI)):
                    # ... however, it is called from a function that cant be instrumented
                    # thus it cant really be instrumented.
                    any_change = True
                    print "Cant instrument %s because its called from %s which we can't instrument" % (called_fn_name, call.containing_function)
                    instr_judgement[called_fn_name] = DIB | DADFA
                    n_rej += 1
                    break
    if any_change:
        print "rejected %d.  instr_judgement changed. Iterating." % n_rej

instr = get_instr()
print "%d instrumnetable fns after dealing with fns called from within uninstrumentable fns" % (len(instr))
print "----------------------------------------------------------------"



"""
Final pass
Say we have fn 'foo' in our white list.

IF we have NEVER seen 'foo' ever get aliased, by which we mean passed as an 
arg to a fn or assigned to a fn pointer) then we leave it on the white list.

ELSE we are worried.  So we consider every other fn with the same type as 'foo' 
in our whole-program merge.

If any of those same-type fns satisfy BOTH of the following conditions, 

*  dont have a body (are lib fns)
*  are aliased 

Then we really worry about 'foo'.  What if 'foo' had same type as std lib fn 
'free' and both 'foo' and 'free' were passed as args to another fn?  

"""

for name in instr_judgement.keys():
    if instr_judgement[name] == OKI:
        if alias(name):
            print "fn %s gets aliased" % name
            # hmm it gets aliased somehow.  worry a little
            ft = fn2funtype[name]
            n=0
            for other_name in funtypes[ft]:
                if other_name == name: continue
                n += 1
                print "  other fn with same type %s -- " % other_name,
                print "hasbody=%d alias=%d" % (hasbody(other_name), alias(other_name))
                if (not(hasbody(other_name))) and (alias(other_name)):
                    # same type fn that is ext and also aliased
                    print "removing %s from whitelist due to fancy analysis" % name
                    instr_judgement[name] = DADFA | DIB
            if n==0: 
                print "  -- no other fns with same type -- ok to instrument"




ninstr = {}
for name in instr:
    disp = instr_judgement[name]
    if not disp in ninstr:
        ninstr[disp] = 0
    ninstr[disp] += 1


for i in range(4):
    if i in ninstr:
        print "instrflags=%d: count=%d" % (i, ninstr[i])

for name in instr_judgement.keys():
    if instr_judgement[name] == OKI:
        print "Intrumenting fun [%s]" % name

                    
                    
f = open(args.output, "w")
for name in instr_judgement.keys():
    if instr_judgement[name] == OKI:
        f.write("NOFILENAME %s\n" % name)
f.close()





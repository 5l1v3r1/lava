#!/usr/bin/python

import argparse
import sys
import os
import colorama
import subprocess
from multiprocessing import cpu_count
from os.path import join, isfile, isdir, dirname, abspath

LLVM_VERSION = "3.6.2"

LAVA_DIR = dirname(abspath(sys.argv[0]))
os.chdir(LAVA_DIR)

# try to import lava.mak as a config file
# if not then resort to default locations for llvm and panda
try:
    def_lines = (line.strip() for line in open("lava.mak", "r") if not line.strip().startswith("#")
             and line.strip() != "")
    def_lines = (line.split(":=") for line in def_lines)
    def_lines = ((line[0].strip(), line[1].strip()) for line in def_lines)
    LAVA_CONFS = dict(def_lines)
    PANDA_DIR = LAVA_CONFS["PANDA_SRC_PATH"]
    LLVM_DIR = LAVA_CONFS["LLVM_SRC_PATH"]
    BUILD_DIR = dirname(LLVM_DIR)
except:
    PANDA_DIR = abspath(join(LAVA_DIR, "../panda"))
    BUILD_DIR = join(os.environ["HOME"], "build")
    LLVM_DIR = join(BUILD_DIR, "llvm-" + LLVM_VERSION)

PANDA_UBUNTU = "https://raw.githubusercontent.com/panda-re/panda/master/panda/scripts/install_ubuntu.sh"
# libc6 needed for compiling btrace
# libjsoncpp needed for fbi json parsing
LAVA_DEPS = ["libjsoncpp-dev", "postgresql", "jq", "python-psycopg2", "python-sqlalchemy",
             "socat", "libpq-dev", "cmake"]

PANDA_MAK = """
# This is an autogenerated file from lava/setup.py.
PANDA_SRC_PATH := {PANDA_DIR}
PANDA_BUILD_DIR := {PANDA_DIR}/build
"""
LLVM_MAK = """
# This is an autogenerated file from lava/setup.py.
LLVM_SRC_PATH := {LLVM_SRC_PATH}
LLVM_BUILD_PATH := {LLVM_BUILD_PATH}
LLVM_BIN_PATH := $(LLVM_BUILD_PATH)/Release/bin
"""

def progress(msg):
    print(colorama.Fore.GREEN + msg + colorama.Fore.RESET)

def error(msg):
    print(colorama.Fore.RED + msg + colorama.Fore.RESET)
    sys.exit(1)

def cmd_to_list(cmd):
    cmd_args = shlex.split(cmd) if isinstance(cmd, str) else cmd
    cmd = subprocess.list2cmdline(cmd_args)
    return cmd, cmd_args

def run(cmd):
    cmd, cmd_args = cmd_to_list(cmd)
    try:
        print("Running [{}] . . . ".format(cmd))
        subprocess.check_call(cmd)
    except subprocess.CalledProcessError:
        error("[{}] cmd did not execute properly.  Return code of {}".format(cmd, rc))
        raise

DOCKER_MAP_DIRS = [LAVA_DIR, os.environ['HOME']]
map_dirs_dedup = []
# quadratic but who cares
for d in DOCKER_MAP_DIRS:
    add = True
    for d2 in DOCKER_MAP_DIRS:
        if d is not d2 and d2.startswith(d):
            add = False
            break
    if add:
        map_dirs_dedup.append(d)

map_dirs_args = sum([['-v', '{0}:{0}'.format(d)] for d in map_dirs_dedup])

def run_docker(cmd):
    _, cmd_args = cmd_to_list(cmd)
    cmd_args = ['docker', 'run', '--rm'] + map_dirs_args + \
        ['-v' '/etc/passwd', '-v' '/etc/group', '-v', '/etc/shadow',
         'lava32'] + cmd_args
    run(cmd_args)

def is_package_installed(pkg):
    if (isfile(join("/usr/bin", pkg)) or
        isfile(join("/bin", pkg))):
        return True
    rc = os.system("dpkg -s {} > /dev/null".format(pkg))
    return rc == 0

def main():
    parser = argparse.ArgumentParser(description='Setup LAVA')
    parser.add_argument('-s', '--skip_docker_build', action='store_true', default = False,
            help = 'Whether or not to skip building docker image')
    args = parser.parse_args()
    IGNORE_DOCKER = args.skip_docker_build

    progress("In LAVA dir at {}".format(LAVA_DIR))
    # check to make sure we are not running as root/sudo
    if os.getuid() == 0:
        error("sudo/root privileges detected. Run as user!\nUSAGE: {}".format(sys.argv[0]))

    progress("Installing LAVA apt-get dependencies")
    if not all(map(is_package_installed, LAVA_DEPS)):
        run(['sudo', 'apt-get', '-y', 'install'] + LAVA_DEPS)

    # check that user has docker install and docker privileges
    # if not exit and tell user to install docker (?)

    # check that user has the LAVA build docker vm build
    # if not run python scripts/build-docker.py
    if not IGNORE_DOCKER:
        progress("Checking that lava32 docker is properly built")
        run(['docker', 'build', '-t', 'lava32', join(LAVA_DIR, docker)])
        compile_cmd = ['cd', join(LAVA_DIR, 'btrace'), '&&', 'bash', 'compile.sh']
        run_docker(['bash', '-c', subprocess.list2cmdline(compile_cmd)])

    # Compile lavaTool inside the docker container.
    progress("Creating $LAVA_DIR/src_clang/config.mak")
    with open("src_clang/config.mak", "w") as f:
        LLVM_DOCKER_DIR = '/llvm-{}'.format(LLVM_VERSION)
        f.write(LLVM_MAK.format(LLVM_BUILD_PATH=LLVM_DOCKER_DIR,
                                LLVM_SRC_PATH=LLVM_DOCKER_DIR))
    run_docker(['make', '-B', '-C', join(LAVA_DIR, 'src_clang'), '-j', str(cpu_count())])

    # ensure /etc/apt/sources.list has all of the deb-src lines uncommented
    patch_sources = join(LAVA_DIR, "scripts/patch-sources.py")
    lines = open("/etc/apt/sources.list")
    filt_lines = [line for line in lines if line.strip().startswith("#deb-src")
                  or line.strip().startswith("# deb-src")]
    if len(filt_lines) > 0:
        progress("Uncommenting {} deb-src lines in".format(len(filt_lines)) +
                 "/etc/apt/sources.list")
        run(['sudo', 'python', patch_sources])

    # check for location of panda in PANDA_DIR
    # make sure that it is PANDA2
    progress("Checking for PANDA in " + PANDA_DIR)
    if not isdir(PANDA_DIR):
        os.chdir(dirname(PANDA_DIR))
        run("wget {}".format(PANDA_UBUNTU))
        run("chmod +x ./install_ubuntu.sh")
        run("./install_ubuntu.sh")
        os.chdir(LAVA_DIR)

    progress("Checking for ODB orm libraries")
    # Ubuntu 16.04 has these
    try:
        run("sudo apt-get install odb libodb-dev libodb-pgsql-dev")
    except subprocess.CalledProcessError:
        os.chdir(BUILD_DIR)
        odb_version="2.4.0"
        odb_baseurl="http://www.codesynthesis.com/download/odb/2.4/"
        run("wget {}/odb_{}-1_amd64.deb".format(odb_baseurl, odb_version))
        run("sudo dpkg -i odb_{}-1_amd64.deb".format(odb_version))
        run("wget {}/libodb-{}.tar.gz".format(odb_baseurl, odb_version))
        run("tar -xzvf libodb-{}.tar.gz".format(odb_version))
        os.chdir("libodb-{}/".format(odb_version))
        run("./configure  && make -j && sudo make install")
        os.chdir("../")
        run("wget {}/libodb-pgsql-{}.tar.gz".format(odb_baseurl, odb_version))
        run("tar -xzvf libodb-pgsql-{}.tar.gz".format(odb_version))
        os.chdir("libodb-pgsql-{}/".format(odb_version))
        run("./configure  && make -j && sudo make install")
        progress("Finished installing ODB libraries")

    ############## Beginning .mak file stuff ######################
    # I think this would be useful, but i'm seperating it out
    # in case anyone thinks it's a bad idea
    # the idea is that if someone wants llvm and panda installed in certain
    # locations, they can make their lava.mak ahead of time
    # then setup.py will parse it and configure the environmet to those specs
    os.chdir(LAVA_DIR)

    progress("Creating $LAVA_DIR/fbi/panda.mak")
    with open(join(LAVA_DIR, "fbi/panda.mak"), "w") as f:
        f.write(PANDA_MAK.format(PANDA_DIR=PANDA_DIR))

    progress("Creating $LAVA_DIR/lava.mak")
    if not isfile(join(LAVA_DIR, "lava.mak")):
        run("cat src_clang/config.mak >> lava.mak")
        run("echo  >> lava.mak")
        run("cat fbi/panda.mak >> lava.mak")

    ############## End .mak file stuff ######################
    progress("Making each component of lava, fbi and lavaTool")
    progress("Compiling fbi")

    os.chdir(join(LAVA_DIR, "fbi"))
    run("make -B -j {}".format(cpu_count()))
    os.chdir(LAVA_DIR)

    return 0

if __name__ == "__main__":
    sys.exit(main())

VITAL operates in four stages.
\begin{enumerate}
\item Compile a version of the target program which has been instrumented with taint queries.
\item Run the instrumented version against various inputs and collect taint results  in a database.
\item Mine the database for potential injectable bugs.
\item Recompile the target with the relevant source code modifications, and test the bug to see if it was successfully injected.
\end{enumerate}

\subsection{Taint queries}
VITAL's taint queries rely on the PANDA dynamic analysis platform [ref], which is based on the QEMU whole-system emulator.
PANDA has a fast and robust dynamic taint analysis which uses LLVM lifting and Clang to ensure that taint propagates through library code and uncommon instructions.
It also tracks taint between processes and the kernel although that is not used by VITAL.
VITAL uses a Clang plugin to insert taint queries at the arguments to each function call in the target's source code.
Each argument is deconstructed into constituent lvals, and, for each, Clang adds a taint query as a \emph{hypervisor call} which notifies PANDA to query the taint system for a specific source-level variable.
VITAL also inserts hypervisor calls into the source code which PANDA uses to record temporal encounters with attack points.

\subsection{Running the program}
Once the instrumented version of the target has been compiled, we run it against a variety of inputs.
Since our approach to gathering data about the program is fundamentally dynamic, we must manually find a representative set of inputs to exercise as much of the program code as possible.
To run the program, we load it as a virtual CD into a PANDA virtual machine and send commands to QEMU over a virtual serial port.
As the hypervisor calls in the program execute, PANDA logs information from each one to a binary file, the \emph{pandalog}.
Because the pandalog is generated by hypercalls inserted into source, it can connect source-level information like variable names and source file locations to the taint queries and attack points.

\subsection{Mine the database}
We then run a new analysis, FIB (Find Injectable Bugs), against the resulting logs.
FIB considers the pandalog entries in temporal order, and finds every possible injectable bug for a particular input given our trace data and analysis method.
It examines each taint query repsult and identifies instances where DUAs are available, maintaining a set of currently available DUAs.
When FIB encounters an attack point, the set of available DUAs is reconsidered and any that have become non-viable because they are too live, for instance

as well as all attack points that occur after that DUA's availability temporally.
It produces a list of pairs of DUAs and attack points; each pair represents a triggering opportunity and a place to insert the bug.



\subsection{Inject the bugs}
For each DUA/attack point pair, we generate the C code which uses the DUA to trigger the bug.
At the point where the DUA is available, we shovel its contents aside into a global variable.
At the attack point, we insert code to trigger an out-of-bounds read or write if and only if the DUA has a magic value which corresponds to bytes in the input.
We then compile and test the modified program on a proof-of-concept input file (the original changed to include the magic value).

VITAL operates in four stages.

\begin{enumerate}
\item Compile a version of the target program which has been instrumented with taint queries.
\item Run the instrumented version against various inputs and collect taint results  in a database.
\item Mine the database for potential injectable bugs.
\item Recompile the target with the relevant source code modifications for a bug, and test to see if it was successfully injected.
\end{enumerate}

\subsection{Taint queries}
VITAL's taint queries rely on the PANDA dynamic analysis platform [ref], which is based on the QEMU whole-system emulator.
PANDA has a fast and robust dynamic taint analysis which uses LLVM lifting and Clang to ensure that taint propagates through library code and uncommon instructions.
It also tracks taint between processes and the kernel although that is not used by VITAL.
VITAL uses a Clang plugin to insert taint queries at the arguments to each function call in the target's source code.
Each argument is deconstructed into constituent lvals, and, for each, Clang adds a taint query as a \emph{hypervisor call} which notifies PANDA to query the taint system for a specific source-level variable.
VITAL also inserts hypervisor calls into the source code which PANDA uses to record temporal encounters with attack points.

\subsection{Running the program}
Once the target has been instrumented with taint queries, we run it against a variety of inputs.
Since our approach to gathering data about the program is fundamentally dynamic, we must take care to choose inputs to maximize code coverage.
To run the program, we load it as a virtual CD into a PANDA virtual machine and send commands to QEMU over a virtual serial port.
As the hypervisor calls in the program execute, PANDA logs results from taint queries and attack point encounters to a binary file, the \emph{pandalog}.
Note that, because the pandalog is generated by hypercalls inserted into source, it can connect source-level information like variable names and source file locations to the taint queries and attack points.
This allows bug injection to occur with knowledge of source-level constructs. 

\subsection{Mine the database}
We then run a new analysis, FIB (Find Injectable Bugs), against the resulting trace logs.
FIB considers the pandalog entries in temporal order, and finds possible injectable bugs for a particular input.
Each taint query result is examined and FIB maintains a set of currently viable DUAs.
One aspect of viability is that a DUA is associated with a specific program point and variable, and only the last encountered DUA is retained in the set. 
This means that, if a DUA is a variable in a loop or in a function that is called many times, the set of viable DUAs only has one
entry for that variable and source line number, thus ensuring that value is up to date and potentially usable.  
Another aspect to viability is that the liveness associated with all the input bytes from which the DUA derives should not become too large.
Now, when FIB encounters an attack point, the entire set of viable DUAs can all be used to inject a vulnerability at that point, via program source changes that introduce data flow between DUA and attack point. 
Each of these pairs, consisting of a DUA and an attack point, is inserted into a database as a potentially injectable bug.  

\subsection{Inject the bugs}
For each DUA/attack point pair, we generate the C code which uses the DUA to trigger the bug.
At the source line and for the variable in the DUA, we inject code to copy its value into a static variable held by a helper function.
At the attack point, we insert code to trigger an out-of-bounds read or write by retrieving the DUA and determining if it matches a magic value.
We then compile and test the modified program on a proof-of-concept input file (the original changed to include the magic value at the right place).

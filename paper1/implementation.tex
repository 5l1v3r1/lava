
The present VITAL implementation operates in four stages to inject and validate buffer overflow vulnerabilities in Linux C source code. 

\begin{enumerate}
\item Compile a version of the target program which has been instrumented with taint queries.
\item Run the instrumented version against various inputs and collect taint and attack point information.
\item Mine the taint results database for potential injectable bugs.
\item Recompile the target with the relevant source code modifications for a bug, and test to see if it was successfully injected.
\end{enumerate}

\subsection{Taint queries}
VITAL's taint queries rely on the PANDA dynamic analysis platform [ref], which is based on the QEMU whole-system emulator.
PANDA has a fast and robust dynamic taint analysis which uses LLVM lifting and Clang to ensure that taint propagates through library code and uncommon instructions.
It also tracks taint between processes and the kernel although that is not used by VITAL.
VITAL uses a Clang plugin to insert taint queries at the arguments to each function call in the target's source code.
Each argument is deconstructed into constituent lvals, and, for each, Clang adds a taint query as a \emph{hypervisor call} which notifies PANDA to query the taint system for a specific source-level variable.
VITAL also inserts hypervisor calls into the source code which PANDA uses to record temporal encounters with attack points.

\subsection{Running the program}
Once the target has been instrumented with taint queries, we run it against a variety of inputs.
Since our approach to gathering data about the program is fundamentally dynamic, we must take care to choose inputs to maximize code coverage.
To run the program, we load it as a virtual CD into a PANDA virtual machine and send commands to QEMU over a virtual serial port.
As the hypervisor calls in the program execute, PANDA logs results from taint queries and attack point encounters to a binary file, the \emph{pandalog}.
Note that, because the pandalog is generated by hypercalls inserted into source, it can connect source-level information like variable names and source file locations to the taint queries and attack points.
This allows bug injection to occur with knowledge of source-level constructs. 


\lstset{language=Python,
        numbers=left, numberstyle=\tiny, stepnumber=2, numbersep=5pt,
        basicstyle=\ttfamily\footnotesize}

\begin{figure}[t]
\begin{lstlisting}
def check_liveness(file_bytes):
  for file_byte in file_bytes:
    if (liveness[file_byte] 
        > max_liveness):
      return False
  return True

def collect_dua(taint_query):
  retained_bytes = []
  for tainted_byte in taint_query:
    if (tainted_byte.tcn <= max_tcn:
    && 
    len(tainted_byte.file_offsets) <= max_card:
    && 
    check_liveness(tainted_byte.file_offsets)):
      retained_bytes += tainted_byte.file_offsets
  duakey = (taint_query.source_loc, 
    taint_query.ast_name)
  duas[duakey] = retained_bytes

def update_liveness_map(tainted_branch):
  for tainted_file_offset in tainted_branch:
    liveness[tainted_file_offset]++

def collect_bugs(attack_point):
  for dua in duas:
    viable_count = 0
    for file_offset in dua:
      if (check_liveness(file_offset)):
        viable_count ++
    if (viable_count >= bytes_needed):
      bugs.add((dua, attack_point))

for event in Pandalog:
  if event.typ is taint_query:
    collect_duas(event);
  if event.typ is tainted_branch: 
    update_liveness(event);
  if event.typ is attack_point: 
    collect_bugs(event);
\end{lstlisting}
\caption{Python-style pseudocode for FIB. 
Panda log is processed in temporal order and the results of taint queries on values and branches are 
used to update the current set of DUAs and input byte liveness.
When an attack point is encountered, all currently viable DUAs are considered as potential data sources to inject a bug.}
\end{figure}

\subsection{Mine the database}
\label{sec:mining}
We then run a new analysis, FIB (Find Injectable Bugs), against the resulting trace logs.
FIB considers the pandalog entries in temporal order, and finds possible injectable bugs for a particular input.
Each taint query result is examined and FIB maintains a set of currently viable DUAs.
One aspect of viability is that a DUA is associated with a specific program point and variable, and only the last encountered DUA is retained in the set. 
This means that, if a DUA is a variable in a loop or in a function that is called many times, the set of viable DUAs only has one
entry for that variable and source line number, thus ensuring that value is up to date and potentially usable.  
Another aspect to viability is that the liveness associated with all the input bytes from which the DUA derives should not become too large.
Now, when FIB encounters an attack point, the entire set of viable DUAs can all be used to inject a vulnerability at that point, via program source changes that introduce data flow between DUA and attack point. 
Each of these pairs, consisting of a DUA and an attack point, is inserted into a database as a potentially injectable bug.  
In the current implementation of VITAL, an attack point is an argument to a function call that can be perturbed by adding a DUA to it. 
This means the argument can be a pointer or some kind of integer type. 
The hope is that changing this value by a large amount may trigger a buffer overflow. 

\subsection{Inject the bugs}
For each DUA/attack point pair, we generate the C code which uses the DUA to trigger the bug.
At the source line and for the variable in the DUA, we inject code to copy its value into a static variable held by a helper function.
At the attack point, an argument to a function call, we insert code that retrieves the DUA value, determines if it matches a magic value, and if so adds it to one of the argument.
We then compile and test the modified program on a proof-of-concept input file (the original changed to include the magic value at the right place).

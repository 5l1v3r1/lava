VITAL has four stages for injecting bugs.
\begin{enumerate}
\item Compile a version of the target program which has been instrumented with taint queries.
\item Run the instrumented version against various inputs and collect the results in a database.
\item Mine the database for potential injectable bugs.
\item Recompile the target with the relevant source code modifications, and test the bug to see if it was successfully injected.
\end{enumerate}

\subsection{Taint queries}
VITAL's taint queries rely on the PANDA dynamic analysis platform [ref], which is based on the QEMU whole-system emulator.
PANDA has a fast and robust dynamic taint analysis which uses LLVM lifting and Clang to ensure that taint propagates through uncommon instructions.
VITAL's Clang plugin, VITALtool, inserts taint queries at the arguments to each function call.
Each taint query consists of a ``hypervisor call'' which notifies PANDA to query the taint system for a specific source-level variable and record the results.
VITALtool also inserts hypervisor calls to record each attack point.

\subsection{Running the program}
Once the instrumented version has been compiled, we run it against a variety of inputs.
Since our approach to gathering data about the program is fundamentally dynamic, we must manually find a representative set of inputs to exercise as much of the program code as possible.
To run the program, we load it as a virtual CD into a PANDA virtual machine and send commands to QEMU over a virtual serial port.
As the hypervisor calls in the program execute, PANDA logs each one to a ``pandalog'' file.
The log connects source-level information like variable names and source file locations to the taint queries and attack points.

\subsection{Mine the database}
We then run a new analysis, FIB (Find Injectable Bugs), against the resulting logs.
FIB finds every possible injectable bug given our trace data and our analysis method.
It examines each taint query and finds instances where DUAs are available, as well as all attack points that occur after that DUA's availability temporally.
It produces a list of pairs of DUAs and attack points; each pair represents a triggering opportunity and a place to insert the bug.

\subsection{Inject the bugs}
For each DUA/attack point pair, we generate the C code which uses the DUA to trigger the bug.
At the point where the DUA is available, we shovel its contents aside into a global variable.
At the attack point, we insert code to trigger an out-of-bounds read or write if and only if the DUA has a magic value which corresponds to bytes in the input.
We then compile and test the modified program on a proof-of-concept input file (the original changed to include the magic value).


\label{section:results}

We evaluated LAVA in two ways.
First, we injected large numbers of bugs into five open source programs: file, readelf from binutils, bash, the command-line verison of Wireshark, tshark, and the image viewer Eye of GNOME.
For each of these, we report various statistics with respect to both the target program and also LAVA's success at injecting bugs. 
Second, we took a random sample of 20 injected bugs for each of these programs and used these to measure detection rates for two commercial and two open source bug finders.

\subsection{Injection Experiments}


\begin{table*}[t]
\centering
\begin{tabular}{c|c|c|c|c|c|c|c|c} 
Name    & Version & lines of C code~\footnote{David Wheeler's SLOCCOUNT} & NQ      &  N(DUA) & N(ATP) & Potential Bugs & \% Tested & Yield \\ \hline
file    & 5.22    & 12927           & 306946  & 673     & 117    & 19261          & 100\%     & 0.367  \\
eog     & 3.4.2   & 22997           & ?       &         & ?      & ?              & ?         &  \\
bash    & 4.3     & 98871           & ?       &         &        &                &           &  \\
readelf & 2.25    & 1327513         & ?       &         & ?      & ?              & ?         &  \\
tshark  & 1.8.2   & 2186252         & ?       &         & ?      & ?              & ?         &  \\
\end{tabular}
\caption{Injection results for open source programs of various sizes.
For each, a single input file was used to generate a PANDA recording, for which a taint analysis was performed on the replay.
NQ is the number of taint queries executed for that replay.
The number of DUAs, Attack points, and potential bugs in the LAVA database for each program is given.
The fraction of bugs actually tested, and the measured yield are also provided, where only runs that result in a segmentation violation are considered true bugs.
}
\end{table*}


Four open source programs were targeted for injecting bugs, and are listed in Table~\ref{table:open-source-targets}.
In this table, the number of lines of C code was computed using \verb+sloccount+.  
For readelf and tshark, we report lines of code for the larger projects which contain them: binutils and Wireshark, as they are not easily extricable [Try to fix this?].
A single input was used with each program to create a recording with PANDA.
The program \verb+/bin/ls+ was the input to \verb+file+ and \verb+readelf+.
The input to \verb+tshark+ was a single iptrace from brendan where did \verb+dualhome.iptrace+ come from? 
The NQ column gives the number of taint queries encountered during replay of that recording, and is, thus, a stand-in for coverage. 
N(DUA) and N(ATP) are the number of DUAs and attack points in the respective tables in the LAVA database after the FIB analysis is complete.
Note that, in order for a DUA or attack point to be counted it must have been decided to be viable for some bug (each bug is a DUA-ATP pair).
As some targets had large numbers of potential bugs, and testing varied from ~10 sec per bug to 2-3 min per bug, not all bugs for
all targets were instantiated.  
For readelf, in particular, the 

As some 

The type of bug selected was a buffer overflow, either read or write.
This sort of bug is still difficult to avoid in C programs, and remains the basis of many important kinds of exploitation because of its dual role in ROP attacks~\footnote{a read is necessary to determine where things are in memory and a write is necessary to change control flow once}.







\begin{table}
\centering
\begin{tabular}{l|l|l|l|l} 
 & \multicolumn{3}{c}{Liveness} &  \\  
$TCN$ &         $[0,1)$ & $[1,10)$ & $[10,100)$ & $[100,+\inf]$ \\  \hline 
$[0,1)$ &       0.526   & 0.466    & 0.208      & 0.218 \\
$[1,10)$ &      --      & 0.119    & --         & --    \\
$[10,100)$ &    --      & --       & 0.000      & --    \\
$[100,+\inf]$ & --      & --       & --         & -- \\ 
\end{tabular}
\end{table}


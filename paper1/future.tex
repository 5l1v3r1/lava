%Limitations:
%- C code only
%- Dataflow is... manufactured, maybe not reflective
%- Limited class of bugs (pointer corruptions)

Future work for LAVA largely involves making the generated corpora look more like the bugs that are found in real programs. First, LAVA currently injects only buffer overflows. But our taint-based analysis overcomes the crucial first hurdle to injecting any kind of bug: making sure that attacker-controlled data can be used in the bug's potential exploitation. As a result, the addition of other classes of bugs, such as temporal safety bugs (use-after-free) and meta-character bugs (e.g. format string) should also be injectable using our approach. There also remains work to be done in making LAVA's data flow more realistic, although even in its current state, the vast majority of the execution of the modified program is realistic. This execution includes the dataflow that leads up to the capture of the DUA, which is often nontrivial.

The last limitation is that LAVA only works on C source code. In principle, our approach would work for any source language with a usable source-to-source rewriting framework. In Python, for example, one could easily implement our taint queries in a CPython plugin that executed the hypervisor call against the address of a variable in memory. Since our approach records the correspondence between source lines and program basic block execution, it would be just as easy to figure out where to edit the Python code as it is in C.

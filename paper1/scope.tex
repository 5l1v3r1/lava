
We restrict our attention, with LAVA, to the injection of bugs into source code.
This makes sense given our interest in using it to assemble large corpora for the purpose of evaluating and developing vulnerability discovery techniques and systems.
Automated bug discovery systems can work on source
code~\cite{Cadar:2008, Ganesh:2009, Haller:2013, Yamaguchi:2014} or on
binaries~\cite{Cha:2012, Wang:2010};
we can easily test binary analysis tools by simply compiling the modified source.
Injecting bugs into binaries or bytecode directly may also be possible using an approach similar to ours, but we do not consider that problem here.
We further narrow our focus to Linux open-source software written in C, due to the availability of source code and source rewriting tools.
As we detail later, a similar approach will work for other languages.

We want the injected bugs to be serious ones, i.e., potentially exploitable.
As a convenient proxy, our current focus is on injecting code that can result in out-of-bounds reads and writes that can be triggered by an attacker-controlled input; in Section~\ref{sec:future} we consider extensions to LAVA to support other bug classes.
We produce a proof-of-concept input to trigger any bug we successfully inject, although we do not attempt to produce an actual exploit.

For the sake of brevity, in this paper we will use the words \emph{bug} and \emph{vulnerability} interchangeably.
In both cases, what we mean is vulnerabilities (in particular, primarily out-of-bounds reads and writes) that cause potentially exploitable crashes.
